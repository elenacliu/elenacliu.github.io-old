<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="单调栈 # 单调栈，顾名思义，是栈中的元素满足一定的单调性。对于从栈底到栈顶单调减少的单调栈，在向栈顶push元素的时候，如果栈顶元素比该元素小，则直接push进去；如果栈顶元素比该元素大，则将栈顶元素pop出来，再比较新的栈顶元素与该元素的大小。实际上我们在使用单调栈的时候，很少直接存储数值，而是存储数组下标，C&#43;&#43;代码如下：
stack&lt;int&gt; monotonestk; // insert the ith number of vector &#39;nums&#39; while(!monotonestk.empty() &amp;&amp; nums[monotonestk.top()] &lt; nums[i])	// 单调递减的栈 monotonestk.pop(); monotonestk.push(i); 实际上在数据结构课堂上老师讲过用这个解决直方图最大矩形的问题，其中一个算法细节还在期中考试考过，但是当时理解并不深刻。
基础应用 # 从知乎专栏上看到这样一个问题，据说是该专栏作者在谷歌的模拟面试题（笔者想起了自己的Google面试经历，说难不难说简单也不简单，还是很考察算法功力的，当然自己有待提升的地方还有很多）：给定一个数组，请返回在这个数组中，每一个数往右边走几步可以到达比它大的第一个数，以数组的形式返回。如果右边没有比它大的数，则认为走-1步。
暴力的做法时间上是$O(n^2)$的，空间上除了保存输入数据以外的额外开销是$O(1)$。每次以第$i$个元素为起点，向右边找第一个大于它的数字，返回下标差。
但很明显我们在这个过程中做了重复计算。以第0个元素为起点时，其实我们遍历到了之后所有的元素（后面其实在不断做重复的遍历），怎么样把一次遍历得到的信息保存下来呢？“存”当然是用数据结构，但是怎么表达元素之间那种“相邻”的大小关系呢？（就比如说这题的，找到下一个比nums[i]大的数在哪里？）
单调栈可以为我们所用。我们需要找到每一个数右边第一个比它大的数字，联系一下单调栈的入栈方式：如果比栈顶小，直接入栈（这时入栈的nums[i]一定不是栈顶元素右边第一个比它大的数）；如果比栈顶大，则先将栈顶的元素pop出来，关键点就在这里，所有元素在出栈的那一刻不就找到了自己右边第一个比自己大的数了吗？
一个细节问题：是不是所有的元素都有出栈的时刻？显然不是。我记得上课时邓公提过一个问题，问我们算法执行完毕后单调栈中的内容是什么含义。当时想不明白，现在明白了：实际上就是在数组中，右边没有比它大的数的那些数的下标（很有点绕口啊）。因此对于无法从栈中弹出的元素，它们的答案就是-1。由于能弹出就可以更新而不能弹出则不能更新，在初始化时将所有元素的答案初始化为-1即可。
每一个位置只会入栈一次（在枚举到它时），并且最多出栈一次，因此时间复杂度为$O(n)$，另外开了一个栈，空间复杂度$O(n)$。
代码如下：
vector&lt;int&gt; getBiggerRight(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; res(nums.size(), -1); stack&lt;int&gt; stk; for(int i = 0; i &lt; nums.size(); i&#43;&#43;) { while(!stk.empty() &amp;&amp; nums[stk.top()] &lt; nums[i]) {	// 单调递减的栈 res[stk.top()] = i - stk.top(); stk.pop(); } stk.push(i); } return res; } 进阶1：LC84.">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="单调栈" />
<meta property="og:description" content="单调栈 # 单调栈，顾名思义，是栈中的元素满足一定的单调性。对于从栈底到栈顶单调减少的单调栈，在向栈顶push元素的时候，如果栈顶元素比该元素小，则直接push进去；如果栈顶元素比该元素大，则将栈顶元素pop出来，再比较新的栈顶元素与该元素的大小。实际上我们在使用单调栈的时候，很少直接存储数值，而是存储数组下标，C&#43;&#43;代码如下：
stack&lt;int&gt; monotonestk; // insert the ith number of vector &#39;nums&#39; while(!monotonestk.empty() &amp;&amp; nums[monotonestk.top()] &lt; nums[i])	// 单调递减的栈 monotonestk.pop(); monotonestk.push(i); 实际上在数据结构课堂上老师讲过用这个解决直方图最大矩形的问题，其中一个算法细节还在期中考试考过，但是当时理解并不深刻。
基础应用 # 从知乎专栏上看到这样一个问题，据说是该专栏作者在谷歌的模拟面试题（笔者想起了自己的Google面试经历，说难不难说简单也不简单，还是很考察算法功力的，当然自己有待提升的地方还有很多）：给定一个数组，请返回在这个数组中，每一个数往右边走几步可以到达比它大的第一个数，以数组的形式返回。如果右边没有比它大的数，则认为走-1步。
暴力的做法时间上是$O(n^2)$的，空间上除了保存输入数据以外的额外开销是$O(1)$。每次以第$i$个元素为起点，向右边找第一个大于它的数字，返回下标差。
但很明显我们在这个过程中做了重复计算。以第0个元素为起点时，其实我们遍历到了之后所有的元素（后面其实在不断做重复的遍历），怎么样把一次遍历得到的信息保存下来呢？“存”当然是用数据结构，但是怎么表达元素之间那种“相邻”的大小关系呢？（就比如说这题的，找到下一个比nums[i]大的数在哪里？）
单调栈可以为我们所用。我们需要找到每一个数右边第一个比它大的数字，联系一下单调栈的入栈方式：如果比栈顶小，直接入栈（这时入栈的nums[i]一定不是栈顶元素右边第一个比它大的数）；如果比栈顶大，则先将栈顶的元素pop出来，关键点就在这里，所有元素在出栈的那一刻不就找到了自己右边第一个比自己大的数了吗？
一个细节问题：是不是所有的元素都有出栈的时刻？显然不是。我记得上课时邓公提过一个问题，问我们算法执行完毕后单调栈中的内容是什么含义。当时想不明白，现在明白了：实际上就是在数组中，右边没有比它大的数的那些数的下标（很有点绕口啊）。因此对于无法从栈中弹出的元素，它们的答案就是-1。由于能弹出就可以更新而不能弹出则不能更新，在初始化时将所有元素的答案初始化为-1即可。
每一个位置只会入栈一次（在枚举到它时），并且最多出栈一次，因此时间复杂度为$O(n)$，另外开了一个栈，空间复杂度$O(n)$。
代码如下：
vector&lt;int&gt; getBiggerRight(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; res(nums.size(), -1); stack&lt;int&gt; stk; for(int i = 0; i &lt; nums.size(); i&#43;&#43;) { while(!stk.empty() &amp;&amp; nums[stk.top()] &lt; nums[i]) {	// 单调递减的栈 res[stk.top()] = i - stk.top(); stk.pop(); } stk.push(i); } return res; } 进阶1：LC84." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://elenacliu.github.io/post/2020-06-09-%E5%8D%95%E8%B0%83%E6%A0%88/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-06-09T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-06-09T00:00:00+00:00" />
<title>单调栈 | cliu&#39;s Blog</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css" integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz&#43;OQteg=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.7e810a06dff91e30ac94f68c31a2f11e914fdd76fe4fe67215eb84b67c4594e6.js" integrity="sha256-foEKBt/5HjCslPaMMaLxHpFP3Xb&#43;T&#43;ZyFeuEtnxFlOY=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>cliu&#39;s Blog</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  
















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>单调栈</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础应用">基础应用</a></li>
    <li><a href="#进阶1lc84-直方图最大矩形">进阶1：LC84. 直方图最大矩形</a></li>
    <li><a href="#进阶2-lc85-最大矩形">进阶2： LC85. 最大矩形</a>
      <ul>
        <li><a href="#方法1转化为上面一题">方法1：转化为上面一题</a></li>
        <li><a href="#方法2动态规划">方法2：动态规划</a></li>
        <li><a href="#方法3位运算加速">方法3：位运算加速</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="单调栈">
  单调栈
  <a class="anchor" href="#%e5%8d%95%e8%b0%83%e6%a0%88">#</a>
</h1>
<p>单调栈，顾名思义，是栈中的元素满足一定的单调性。对于从栈底到栈顶单调减少的单调栈，在向栈顶push元素的时候，如果栈顶元素比该元素小，则直接push进去；如果栈顶元素比该元素大，则将栈顶元素pop出来，再比较新的栈顶元素与该元素的大小。实际上我们在使用单调栈的时候，很少直接存储数值，而是存储数组下标，C++代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> monotonestk;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// insert the ith number of vector &#39;nums&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>monotonestk.empty() <span style="color:#f92672">&amp;&amp;</span> nums[monotonestk.top()] <span style="color:#f92672">&lt;</span> nums[i])	<span style="color:#75715e">// 单调递减的栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    monotonestk.pop();
</span></span><span style="display:flex;"><span>monotonestk.push(i);
</span></span></code></pre></div><p>实际上在数据结构课堂上老师讲过用这个解决直方图最大矩形的问题，其中一个算法细节还在期中考试考过，但是当时理解并不深刻。</p>
<h2 id="基础应用">
  基础应用
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80%e5%ba%94%e7%94%a8">#</a>
</h2>
<p>从<a href="https://zhuanlan.zhihu.com/p/26465701">知乎专栏</a>上看到这样一个问题，据说是该专栏作者在谷歌的模拟面试题（笔者想起了自己的Google面试经历，说难不难说简单也不简单，还是很考察算法功力的，当然自己有待提升的地方还有很多）：给定一个数组，请返回在这个数组中，每一个数往右边走几步可以到达比它大的第一个数，以数组的形式返回。如果右边没有比它大的数，则认为走-1步。</p>
<p>暴力的做法时间上是$O(n^2)$的，空间上除了保存输入数据以外的额外开销是$O(1)$。每次以第$i$个元素为起点，向右边找第一个大于它的数字，返回下标差。</p>
<p>但很明显我们在这个过程中做了重复计算。以第0个元素为起点时，其实我们遍历到了之后所有的元素（后面其实在不断做重复的遍历），怎么样把一次遍历得到的信息保存下来呢？“存”当然是用数据结构，但是怎么表达元素之间那种“相邻”的大小关系呢？（就比如说这题的，找到下一个比<code>nums[i]</code>大的数在哪里？）</p>
<p>单调栈可以为我们所用。我们需要找到每一个数右边第一个比它大的数字，联系一下单调栈的入栈方式：如果比栈顶小，直接入栈（这时入栈的<code>nums[i]</code>一定不是栈顶元素右边第一个比它大的数）；如果比栈顶大，则<strong>先将栈顶的元素pop出来</strong>，<del>关键点就在这里</del>，所有元素在出栈的那一刻不就找到了自己右边第一个比自己大的数了吗？</p>
<p>一个细节问题：是不是所有的元素都有出栈的时刻？显然不是。我记得上课时邓公提过一个问题，问我们算法执行完毕后单调栈中的内容是什么含义。当时想不明白，现在明白了：实际上就是在数组中，右边没有比它大的数的那些数的下标（<del>很有点绕口啊</del>）。因此对于无法从栈中弹出的元素，它们的答案就是-1。由于能弹出就可以更新而不能弹出则不能更新，在初始化时将所有元素的答案初始化为-1即可。</p>
<p>每一个位置只会入栈一次（在枚举到它时），并且最多出栈一次，因此时间复杂度为$O(n)$，另外开了一个栈，空间复杂度$O(n)$。</p>
<p>代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> getBiggerRight(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> res(nums.size(), <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stk;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nums.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>stk.empty() <span style="color:#f92672">&amp;&amp;</span> nums[stk.top()] <span style="color:#f92672">&lt;</span> nums[i]) {	<span style="color:#75715e">// 单调递减的栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            res[stk.top()] <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> stk.top();
</span></span><span style="display:flex;"><span>            stk.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        stk.push(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="进阶1lc84-直方图最大矩形">
  进阶1：LC84. 直方图最大矩形
  <a class="anchor" href="#%e8%bf%9b%e9%98%b61lc84-%e7%9b%b4%e6%96%b9%e5%9b%be%e6%9c%80%e5%a4%a7%e7%9f%a9%e5%bd%a2">#</a>
</h2>
<p>先来说说一个trivial的思路（不是官方解答）。既然上面的方法可以求出右侧第一个比自己大的数，那么同样可以求出左、右侧第一个比自己小的数。</p>
<p>首先明确两点。既然答案是最大矩形，那么这个矩形的高度一定是直方图中某一个小条形的高度；矩形的宽度一定是向两边延伸的最大值（即再往左/右一定就遇到比自己小的高度了，不能再以当前高度为矩形的高了）。明确了这两点以后可以知道，只需要做三次线性扫描，答案就可以出来：</p>
<ol>
<li>从左往右，找右侧第一个比自己小的数的坐标</li>
<li>从右往左，找左侧第一个比自己小的数的坐标</li>
<li>无特殊的扫描方向。就从左往右吧，依次计算以各个条形高度为矩形的高度时，矩形的面积。在此过程中取最大值，即为所求。</li>
</ol>
<p>代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> largestRectangleArea(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> heights) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> heights.size();
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stk;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 下面这样初始化的理由是：可以认为-1和n处的高度为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> left(n, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);        <span style="color:#75715e">// 如果左侧没有比自己小的，则认为比自己小的都在-1处
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> right(n, n);        <span style="color:#75715e">// 如果右侧没有比自己小的，则认为比自己小的都在n处
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>stk.empty() <span style="color:#f92672">&amp;&amp;</span> heights[stk.top()] <span style="color:#f92672">&gt;</span> heights[i]) {
</span></span><span style="display:flex;"><span>                right[stk.top()] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                stk.pop();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            stk.push(i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        stk <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>stk.empty() <span style="color:#f92672">&amp;&amp;</span> heights[stk.top()] <span style="color:#f92672">&gt;</span> heights[i]) {
</span></span><span style="display:flex;"><span>                left[stk.top()] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                stk.pop();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            stk.push(i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">=</span> max(ans, heights[i] <span style="color:#f92672">*</span> (right[i] <span style="color:#f92672">-</span> left[i] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>官方解答：</p>
<p><strong>单调栈+常数优化</strong></p>
<p>再思考一个问题：能不能通过一遍扫描，求出<em>左</em>边界和<em>右</em>边界？</p>
<p>拿单调增的栈举例，从左往右扫描，则元素入栈时，可求出左边第一个比自己小于等于的数；元素出栈时，可求出右边第一个比自己小的数。</p>
<p>但我们需要求的是左边比自己小的数！会不会影响结果呢？</p>
<p>答案是不会。因为如果有**在单调栈中连续的（这个限定非常重要，因为并不是只要在直方图中高度相同就可以在单调栈中处于连续位置，前提是在直方图里，它们之间没有更小高度的条形）**相同高度的条形，则最左边的条形可以求出正确的左边界，而这些条形的右边界都是对的。所以即便中间那些高度的条形求出的结果不正确（比实际值小），也不会影响最后的答案！</p>
<p>优化后的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> largestRectangleArea(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> heights) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> heights.size();
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stk;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 下面这样初始化的理由是：可以认为-1和n处的高度为0 (所谓的哨兵技巧)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> left(n, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);        <span style="color:#75715e">// 如果左侧没有比自己小的，则认为比自己小的都在-1处
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> right(n, n);        <span style="color:#75715e">// 如果右侧没有比自己小的，则认为比自己小的都在n处
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>stk.empty() <span style="color:#f92672">&amp;&amp;</span> heights[stk.top()] <span style="color:#f92672">&gt;</span> heights[i]) {
</span></span><span style="display:flex;"><span>                right[stk.top()] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                stk.pop();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>stk.empty())
</span></span><span style="display:flex;"><span>                left[i] <span style="color:#f92672">=</span> stk.top();
</span></span><span style="display:flex;"><span>            stk.push(i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">=</span> max(ans, heights[i] <span style="color:#f92672">*</span> (right[i] <span style="color:#f92672">-</span> left[i] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="进阶2-lc85-最大矩形">
  进阶2： LC85. 最大矩形
  <a class="anchor" href="#%e8%bf%9b%e9%98%b62-lc85-%e6%9c%80%e5%a4%a7%e7%9f%a9%e5%bd%a2">#</a>
</h2>
<p>这道题确实有难度，我自己只能想到暴力解法。</p>
<h3 id="方法1转化为上面一题">
  方法1：转化为上面一题
  <a class="anchor" href="#%e6%96%b9%e6%b3%951%e8%bd%ac%e5%8c%96%e4%b8%ba%e4%b8%8a%e9%9d%a2%e4%b8%80%e9%a2%98">#</a>
</h3>
<p>不得不说好难想到！不过官网题解倒是能让我们理解这个做法是怎么一步步得到的。</p>
<ul>
<li>解法1：枚举所有的(x1, y1)和(x2 y2)，统计以之为对角线的矩形的面积。</li>
<li>解法2：枚举所有的(x, y)，统计以(0, 0), (x, y)为对角线的最大矩形面积。这时候出现一个概念：每一行中每一个方块连续的“1”的数量。有了这个概念后，我们实际上可以得到一系列旋转了90°的直方图。</li>
</ul>
<p>从解法2，联系上一题可以得到时间复杂度$O(MN)$，空间复杂度$O(MN)$（优化后可以达到$O(M)$）的算法。</p>
<p>求最大矩形的面积，我们不妨逐行来看，求出每一行上的<code>heights[]</code>即可。</p>
<p>代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">leetcode84</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> heights) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> heights.size();
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stk;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 下面这样初始化的理由是：可以认为-1和n处的高度为0 (所谓的哨兵技巧)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> left(n, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);        <span style="color:#75715e">// 如果左侧没有比自己小的，则认为比自己小的都在-1处
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> right(n, n);        <span style="color:#75715e">// 如果右侧没有比自己小的，则认为比自己小的都在n处
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>stk.empty() <span style="color:#f92672">&amp;&amp;</span> heights[stk.top()] <span style="color:#f92672">&gt;</span> heights[i]) {
</span></span><span style="display:flex;"><span>                right[stk.top()] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                stk.pop();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>stk.empty())
</span></span><span style="display:flex;"><span>                left[i] <span style="color:#f92672">=</span> stk.top();
</span></span><span style="display:flex;"><span>            stk.push(i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">=</span> max(ans, heights[i] <span style="color:#f92672">*</span> (right[i] <span style="color:#f92672">-</span> left[i] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maximalRectangle(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> matrix) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> matrix.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(m <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> matrix[<span style="color:#ae81ff">0</span>].size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 其实可以空间优化到O(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> height(m, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(n, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            height[<span style="color:#ae81ff">0</span>][i] <span style="color:#f92672">=</span> matrix[<span style="color:#ae81ff">0</span>][i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                height[i][j] <span style="color:#f92672">=</span> matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">?</span> height[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">=</span> max(ans, leetcode84(height[i]));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>空间优化部分：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>		<span style="color:#75715e">// 其实可以空间优化到O(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> preheight(n, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> height(n, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            preheight[i] <span style="color:#f92672">=</span> matrix[<span style="color:#ae81ff">0</span>][i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">=</span> max(ans, leetcode84(preheight));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                height[j] <span style="color:#f92672">=</span> matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">?</span> preheight[j] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            preheight <span style="color:#f92672">=</span> height;
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">=</span> max(ans, leetcode84(preheight));
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><h3 id="方法2动态规划">
  方法2：动态规划
  <a class="anchor" href="#%e6%96%b9%e6%b3%952%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#</a>
</h3>
<p>动态规划实际上就是找每层之间的联系。</p>
<p>我们可以认为本题是从第0层到第m-1层逐层扩展。方法1中逐层化解为84题，每层都是根据heights数组重新求一遍left和right。实际上我们可以延续动态规划的思想，类似<code>height[]</code>的逐层更新，从上一层的<code>left[]</code>和<code>right[]</code>得到下一层的<code>left[]</code>和<code>right[]</code>。</p>
<p>我们可以画一张图表示第i-1层和第i层之间的关系：</p>
<p>从图中可以看出，第i层的left或者right产生变化当且仅当这一层出现过0，具体转移方程见图。</p>
<p><img src="https://i.loli.net/2020/06/10/K13JrPfB8TceZlE.png" alt="85pic.png" /></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maximalRectangle(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;&amp;</span> matrix) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> matrix.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(m <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> matrix[<span style="color:#ae81ff">0</span>].size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> preheight(n, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> height(n, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> left(n, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> preleft(n, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> right(n, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> preright(n, n);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> curleft, curright;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// update height
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                height[j] <span style="color:#f92672">=</span> matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#f92672">?</span> preheight[j] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// update left
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            curleft <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>)
</span></span><span style="display:flex;"><span>                    left[j] <span style="color:#f92672">=</span> max(preleft[j], curleft);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>) {
</span></span><span style="display:flex;"><span>                    curleft <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>                    left[j] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            curright <span style="color:#f92672">=</span> n;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; j<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>)
</span></span><span style="display:flex;"><span>                    right[j] <span style="color:#f92672">=</span> min(preright[j], curright);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>) {
</span></span><span style="display:flex;"><span>                    curright <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>                    right[j] <span style="color:#f92672">=</span> n;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                ans <span style="color:#f92672">=</span> max(ans, height[j] <span style="color:#f92672">*</span> (right[j] <span style="color:#f92672">-</span> left[j] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            preheight <span style="color:#f92672">=</span> height;
</span></span><span style="display:flex;"><span>            preleft <span style="color:#f92672">=</span> left;
</span></span><span style="display:flex;"><span>            preright <span style="color:#f92672">=</span> right;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="方法3位运算加速">
  方法3：位运算加速
  <a class="anchor" href="#%e6%96%b9%e6%b3%953%e4%bd%8d%e8%bf%90%e7%ae%97%e5%8a%a0%e9%80%9f">#</a>
</h3>
<p>看到评论区有大神用二进制位表示状态</p>
<p>是用python解决的，因为用C语言表示会溢出（精度不足）</p>
<p>今天实在太累，明天看懂了再继续写吧</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>





 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础应用">基础应用</a></li>
    <li><a href="#进阶1lc84-直方图最大矩形">进阶1：LC84. 直方图最大矩形</a></li>
    <li><a href="#进阶2-lc85-最大矩形">进阶2： LC85. 最大矩形</a>
      <ul>
        <li><a href="#方法1转化为上面一题">方法1：转化为上面一题</a></li>
        <li><a href="#方法2动态规划">方法2：动态规划</a></li>
        <li><a href="#方法3位运算加速">方法3：位运算加速</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












