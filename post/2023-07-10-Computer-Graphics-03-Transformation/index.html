<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="本文内容总结自闫令琪老师的《GAMES101-现代计算机图形学入门》。
课程主页：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html
网课链接：https://www.bilibili.com/video/BV1X7411F744
Transformation Scale matrix \[ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}= \begin{pmatrix}s_x &amp; 0\\0 &amp; s_y\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix} \]
Reflection matrix \[ \begin{pmatrix}-x\\y\end{pmatrix}= \begin{pmatrix}-1 &amp; 0\\0 &amp; 1\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix} \]
Shear matrix \[ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}=\begin{pmatrix}1&amp;a\\0&amp;1\end{pmatrix} \begin{pmatrix}x\\y\end{pmatrix} \]
Rotation matrix 默认绕着原点、逆时针方向旋转。
Homogenous coordinates 为什么要引入齐次坐标？因为平移变换不是一种线性变换。
平移变换无法直接表示成矩阵乘的形式。 \[ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}=\begin{pmatrix}a&amp;b\\c&amp;d\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}&#43;\begin{pmatrix}t_x\\t_y\end{pmatrix} \] 解决方案：增加一个维度（w-coordinate）
2d point: \((x,y,1)^T\)
2d vector：\((x,y,0)^T\)
\(\begin{pmatrix}x\\y\\w\end{pmatrix}\) Is the 2D point \(\begin{pmatrix}x/w\\y/w\\1\end{pmatrix}\), \(w\neq0\)
一个点加上另一个点，在齐次坐标下表示的是两个点的中点。
Affine transformation Affine map = linear map &#43; translation \[ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}= \begin{pmatrix}a &amp; b\\c &amp; d\end{pmatrix}\cdot \begin{pmatrix}x \\ y\end{pmatrix} &#43; \begin{pmatrix}t_x\\t_y\end{pmatrix} \] using homogenous coordinates: \[ \begin{pmatrix}x&#39;\\y&#39;\\1\end{pmatrix}= \begin{pmatrix}a &amp; b &amp; t_x \\ c &amp; d &amp; t_y \\ 0 &amp; 0 &amp; 1\end{pmatrix}\cdot \begin{pmatrix}x\\y\\1\end{pmatrix} \] 表示 2D 场景下的仿射变换时，最后一行才是 0 0 1（比如投影变换就不是）。">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="Computer Graphics 03 Transformation" />
<meta property="og:description" content="本文内容总结自闫令琪老师的《GAMES101-现代计算机图形学入门》。
课程主页：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html
网课链接：https://www.bilibili.com/video/BV1X7411F744
Transformation Scale matrix \[ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}= \begin{pmatrix}s_x &amp; 0\\0 &amp; s_y\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix} \]
Reflection matrix \[ \begin{pmatrix}-x\\y\end{pmatrix}= \begin{pmatrix}-1 &amp; 0\\0 &amp; 1\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix} \]
Shear matrix \[ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}=\begin{pmatrix}1&amp;a\\0&amp;1\end{pmatrix} \begin{pmatrix}x\\y\end{pmatrix} \]
Rotation matrix 默认绕着原点、逆时针方向旋转。
Homogenous coordinates 为什么要引入齐次坐标？因为平移变换不是一种线性变换。
平移变换无法直接表示成矩阵乘的形式。 \[ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}=\begin{pmatrix}a&amp;b\\c&amp;d\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}&#43;\begin{pmatrix}t_x\\t_y\end{pmatrix} \] 解决方案：增加一个维度（w-coordinate）
2d point: \((x,y,1)^T\)
2d vector：\((x,y,0)^T\)
\(\begin{pmatrix}x\\y\\w\end{pmatrix}\) Is the 2D point \(\begin{pmatrix}x/w\\y/w\\1\end{pmatrix}\), \(w\neq0\)
一个点加上另一个点，在齐次坐标下表示的是两个点的中点。
Affine transformation Affine map = linear map &#43; translation \[ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}= \begin{pmatrix}a &amp; b\\c &amp; d\end{pmatrix}\cdot \begin{pmatrix}x \\ y\end{pmatrix} &#43; \begin{pmatrix}t_x\\t_y\end{pmatrix} \] using homogenous coordinates: \[ \begin{pmatrix}x&#39;\\y&#39;\\1\end{pmatrix}= \begin{pmatrix}a &amp; b &amp; t_x \\ c &amp; d &amp; t_y \\ 0 &amp; 0 &amp; 1\end{pmatrix}\cdot \begin{pmatrix}x\\y\\1\end{pmatrix} \] 表示 2D 场景下的仿射变换时，最后一行才是 0 0 1（比如投影变换就不是）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://elenacliu.github.io/post/2023-07-10-Computer-Graphics-03-Transformation/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-07-10T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-07-10T00:00:00+00:00" />
<title>Computer Graphics 03 Transformation | cliu&#39;s Blog</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css" integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz&#43;OQteg=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.ec590097bd4847831e820a7c2cd140675b5708c9b6967bb22176f61e5ae319bc.js" integrity="sha256-7FkAl71IR4Meggp8LNFAZ1tXCMm2lnuyIXb2HlrjGbw=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>cliu&#39;s Blog</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  
















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Computer Graphics 03 Transformation</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  




  </aside>
  
 
      </header>

      
      
  <article class="markdown"><p>本文内容总结自闫令琪老师的《GAMES101-现代计算机图形学入门》。</p>
<p>课程主页：<a
href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html</a></p>
<p>网课链接：<a
href="https://www.bilibili.com/video/BV1X7411F744/">https://www.bilibili.com/video/BV1X7411F744</a></p>
<h1 id="transformation">Transformation</h1>
<h2 id="scale-matrix">Scale matrix</h2>
<p><span class="math display">\[
\begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}=
\begin{pmatrix}s_x &amp; 0\\0 &amp;
s_y\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}
\]</span></p>
<h2 id="reflection-matrix">Reflection matrix</h2>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102153297.png" alt="image-20230710下午44412437" style="zoom:50%;" />
<span class="math display">\[
\begin{pmatrix}-x\\y\end{pmatrix}=
\begin{pmatrix}-1 &amp; 0\\0 &amp;
1\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}
\]</span></p>
<h2 id="shear-matrix">Shear matrix</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102153520.png"
alt="image-20230710下午44643013" /> <span class="math display">\[
\begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}=\begin{pmatrix}1&amp;a\\0&amp;1\end{pmatrix}
\begin{pmatrix}x\\y\end{pmatrix}
\]</span></p>
<h2 id="rotation-matrix">Rotation matrix</h2>
<p>默认绕着原点、逆时针方向旋转。</p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102153951.png" alt="image-20230710下午45946837" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102153578.png" alt="image-20230710下午50130812" style="zoom:50%;" /></p>
<h2 id="homogenous-coordinates">Homogenous coordinates</h2>
<p>为什么要引入齐次坐标？因为平移变换不是一种线性变换。</p>
<p>平移变换无法直接表示成矩阵乘的形式。 <span class="math display">\[
\begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}=\begin{pmatrix}a&amp;b\\c&amp;d\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}+\begin{pmatrix}t_x\\t_y\end{pmatrix}
\]</span> 解决方案：增加一个维度（w-coordinate）</p>
<p>2d point: <span class="math inline">\((x,y,1)^T\)</span></p>
<p>2d vector：<span class="math inline">\((x,y,0)^T\)</span></p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102153412.png" alt="image-20230710下午53642136" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102154016.png" alt="image-20230710下午54417840" style="zoom:50%;" /></p>
<p><span
class="math inline">\(\begin{pmatrix}x\\y\\w\end{pmatrix}\)</span> Is
the 2D point <span
class="math inline">\(\begin{pmatrix}x/w\\y/w\\1\end{pmatrix}\)</span>,
<span class="math inline">\(w\neq0\)</span></p>
<p>一个点加上另一个点，在齐次坐标下表示的是两个点的中点。</p>
<h2 id="affine-transformation">Affine transformation</h2>
<p>Affine map = linear map + translation <span class="math display">\[
\begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}=
\begin{pmatrix}a &amp; b\\c &amp; d\end{pmatrix}\cdot
\begin{pmatrix}x \\ y\end{pmatrix} +
\begin{pmatrix}t_x\\t_y\end{pmatrix}
\]</span> using homogenous coordinates: <span class="math display">\[
\begin{pmatrix}x&#39;\\y&#39;\\1\end{pmatrix}=
\begin{pmatrix}a &amp; b &amp; t_x \\ c &amp; d &amp; t_y \\ 0 &amp; 0
&amp; 1\end{pmatrix}\cdot
\begin{pmatrix}x\\y\\1\end{pmatrix}
\]</span> 表示 2D 场景下的仿射变换时，最后一行才是 0 0
1（比如投影变换就不是）。</p>
<p>类似的，四元组可以方便地表示 3D 空间的线性变换。</p>
<p>关于四元组的学习资料：</p>
<ol type="1">
<li><a
href="https://krasjet.github.io/quaternion/quaternion.pdf">https://krasjet.github.io/quaternion/quaternion.pdf</a></li>
<li>如何形象地理解四元数？ - 知乎 <a
href="https://www.zhihu.com/question/23005815/answer/483589712">https://www.zhihu.com/question/23005815/answer/483589712</a></li>
</ol>
<h2 id="inverse-transformation">Inverse transformation</h2>
<p><span class="math inline">\(\mathrm{M}^{-1}\)</span> is the inverse
of transform <span class="math inline">\(\mathrm{M}\)</span></p>
<h2 id="composing-complex-transforms">Composing complex transforms</h2>
<p>复杂的变换可以通过一系列简单的变换得到，但是变换的过程非常重要。
<span class="math display">\[
A_n(...A_2(A_1(\mathrm{x})))=\mathrm{A}_n\cdots
\mathrm{A}_2\cdot\mathrm{A}_1\cdot\begin{pmatrix}x\\y\\1\end{pmatrix}
\]</span></p>
<h2 id="decomposing-complex-transforms">Decomposing complex
transforms</h2>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102154150.png"
alt="image-20230710下午82416312" />
<figcaption aria-hidden="true">image-20230710下午82416312</figcaption>
</figure>
<p><span class="math display">\[
R_\theta=\begin{pmatrix}\cos\theta&amp;-\sin\theta\\\sin\theta&amp;\cos\theta\end{pmatrix}
\]</span></p>
<p><span class="math display">\[
R_{-\theta}=R_\theta^T
\]</span></p>
<p><span class="math display">\[
R_{-\theta}=R_{\theta}^{-1}, by\ definition
\]</span></p>
<p>（因为逆时针旋转<span
class="math inline">\(\theta\)</span>和顺时针旋转<span
class="math inline">\(\theta\)</span>就是互逆的操作）</p>
<p>注意：逆矩阵和转置矩阵相等的矩阵叫做正交矩阵。</p>
<h2 id="d-transforms">3D transforms</h2>
<p>Using homogenous coordinates again:</p>
<ul>
<li>3D point = <span class="math inline">\((x,y,z,1)^T\)</span></li>
<li>3D vector = <span class="math inline">\((x,y,z,0)^T\)</span></li>
</ul>
<p>In general, <span class="math inline">\((x,y,z,w), w\neq0\)</span> is
the 3D point: <span class="math display">\[
(x/w,y/w,z/w)
\]</span></p>
<p>Use 4x4 matrices for affine transformations:</p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102154039.png" alt="image-20230710下午90105276" style="zoom:50%;" /></p>
<p>Linear transformation first, then translation.</p>
<h3 id="rotation-around-x--y--or-z--axis">Rotation around x-, y-, or z-
axis</h3>
<p>绕着 x- axis 旋转： <span class="math display">\[
\mathrm{R}_x(\alpha)=
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \cos\alpha &amp;-\sin\alpha &amp; 0\\
0 &amp; \sin\alpha &amp; \cos\alpha &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}
\]</span> 绕着 y- axis 旋转： <span class="math display">\[
\mathrm{R}_y(\alpha)=
\begin{pmatrix}
\cos\alpha &amp; 0 &amp; \sin\alpha &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0\\
-\sin\alpha &amp; 0 &amp; \cos\alpha &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}
\]</span> 注意这里绕着 y- axis 旋转之所以左上角是 <span
class="math inline">\(\sin\alpha\)</span> 而非 <span
class="math inline">\(-\sin\alpha\)</span>，是因为课程默认右手系，从 y
轴的角度看，应该是 z 轴充当 2D 平面上的 x 轴，x 轴充当 2D 平面上的 y
轴（这样才能符合右手螺旋定则得到 y 轴的方向，并且依照右手旋转的方向定出
<span class="math inline">\(z-O-x\)</span>
平面的逆时针方向就是手转动的方向：从 z 轴指向 x
轴），而在这里矩阵中的顺序是先 x 轴后 z 轴，是反的，所以 <span
class="math inline">\(x-O-z\)</span> 平面的顺时针方向等于 <span
class="math inline">\(z-O-x\)</span>
平面的逆时针方向，角度需要添加负号。</p>
<p>（本质上是因为轮换顺序反了，即便是左手系也会出现这个问题）</p>
<p>绕着 z- axis 旋转： <span class="math display">\[
\mathrm{R}_z(\alpha)=
\begin{pmatrix}
\cos\alpha &amp; -\sin\alpha &amp; 0 &amp; 0 \\
\sin\alpha &amp; \cos\alpha &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp;0 &amp; 1
\end{pmatrix}
\]</span></p>
<p>欧拉角： <span class="math display">\[
\mathrm{R}_{xyz}(\alpha,\beta,\gamma)=\mathrm{R}_x(\alpha)\mathrm{R}_y(\beta)\mathrm{R}_z(\gamma)
\]</span></p>
<h3 id="rodrigues-rotation-formula">Rodrigue’s rotation formula</h3>
<p>rotation by angle <span class="math inline">\(\alpha\)</span> around
axis <span class="math inline">\(\mathrm{n}\)</span>:</p>
<p>只有向量表示旋转轴不太合理，因此这里默认是过原点的向量。 <span
class="math display">\[
\mathrm{R}(\mathrm{n},\alpha)=\cos(\alpha)\mathrm{I}+(1-\cos(\alpha))\mathrm{n}\mathrm{n}^T+\sin(\alpha)
\begin{pmatrix}
0 &amp; -n_z &amp; n_y \\
n_z &amp; 0 &amp; -n_x \\
-n_y &amp; n_x &amp; 0 \\
\end{pmatrix}
\]</span> 最后的矩阵就是叉积的 dual matrix。</p>
<p>四元数：为了旋转与旋转之间的插值。</p>
<p>比如：二维旋转15度对应矩阵<span
class="math inline">\(A\)</span>，二维旋转25度对应矩阵<span
class="math inline">\(B\)</span>，<span
class="math inline">\((A+B)/2\)</span>代表的矩阵并不是旋转20度的矩阵。</p>
<h2 id="viewing-transformation">Viewing transformation</h2>
<h3 id="view视图-camera-transformation">View（视图）/ camera
transformation</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102154026.png"
alt="image-20230710下午93933212" />
<figcaption aria-hidden="true">image-20230710下午93933212</figcaption>
</figure>
<p>相机在世界坐标系中的位置：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102154183.png"
alt="image-20230710下午94454590" />
<figcaption aria-hidden="true">image-20230710下午94454590</figcaption>
</figure>
<p>相机坐标系：</p>
<p>约定相机位于原点，向上方向为 y 方向，朝着 -z 方向看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102154852.png" alt="image-20230710下午94325730" style="zoom:50%;" /></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111029900.png"
alt="image-20230711上午102918552" />
<figcaption aria-hidden="true">image-20230711上午102918552</figcaption>
</figure>
<p>将相机从世界坐标系“移动”到相机坐标系（本质上是坐标系的变换，但是老师认为坐标系的改变导致物体坐标变化不好理解，拿物体的移动举例更容易理解）</p>
<ul>
<li><p>translates e to origin <span class="math display">\[
T_{view}=
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; -x_e \\
0 &amp; 1 &amp; 0 &amp; -y_e \\
0 &amp; 0 &amp; 1 &amp; -z_e \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\]</span></p></li>
<li><p>rotates g to -Z, rotates t to Y, rotates (g x t) to X</p>
<ul>
<li>consider its <em>inverse</em> rotation: X to (g x t), Y to t, Z to
-g <span class="math display">\[
R^{-1}_{view}=
\begin{bmatrix}
x_{\hat g\times\hat t} &amp; x_t &amp; x_{-g} &amp; 0 \\
y_{\hat g\times\hat t} &amp; y_t &amp; y_{-g} &amp; 0 \\
z_{\hat g\times\hat t} &amp; z_t &amp; z_{-g} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\]</span> 由于旋转矩阵是正交矩阵，所以它的逆矩阵等于它的转置： <span
class="math display">\[
R_{view}=
\begin{bmatrix}
x_{\hat g\times\hat t} &amp; y_{\hat g\times\hat t} &amp; z_{\hat
g\times\hat t} &amp; 0 \\
x_t &amp; y_t &amp; z_t &amp; 0 \\
x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\]</span></li>
</ul></li>
</ul>
<p>因此，视图变换的矩阵是：</p>
<p><span class="math display">\[
M_{view}=R_{view}T_{view}
\]</span></p>
<h2 id="projection-transformation">Projection Transformation</h2>
<p>3D to 2D</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111045525.png"
alt="image-20230711上午104444349" />
<figcaption aria-hidden="true">image-20230711上午104444349</figcaption>
</figure>
<h3 id="orthographic-transformation">Orthographic transformation</h3>
<p>正交投影，3D 的平行线在 2D 上还是平行的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111048018.png" alt="image-20230711上午104812676" style="zoom:50%;" /></p>
<p>b: bottom</p>
<p>t: top</p>
<p>f: far, z 小</p>
<p>n: near, z 大</p>
<p>这也就是为什么 OpenGL 选择的是左手系，因为这样 far 就比 near 的 z
值更大了。</p>
<p>Translate (center to origin) first, then scale to length/width/height
to 2 <span class="math display">\[
M_{ortho}=
\begin{pmatrix}
\frac{2}{r-t} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{pmatrix}
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; -\frac{r+t}{2} \\
0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\
0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2} \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{pmatrix}
\]</span> 投影变换的过程会出现 cube
中物体的拉伸，但是最后会进行视口的变换，会 scale 回来。</p>
<h3 id="perceptive-transformation">Perceptive transformation</h3>
<p>透视投影，近大远小。</p>
<p>相机有个 frustum</p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111115615.png" alt="image-20230711上午110351824" style="zoom:50%;" /></p>
<p>先将远的大平面“挤”成和近的平面一样大的平面，再做正交投影。 <span
class="math display">\[
M_{persp2ortho}=
\]</span>
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111115310.png" alt="image-20230711上午111239716" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111115034.png" alt="image-20230711上午111344189" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111115001.png" alt="image-20230711上午111530145" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111116351.png" alt="image-20230711上午111628919" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111132377.png" alt="image-20230711上午113237717" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111200562.png" alt="image-20230711下午120053458" style="zoom:50%;" />
<span class="math display">\[
M_{persp2ortho}=
\begin{pmatrix}
n &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; n &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; n + f &amp; -nf \\
0 &amp; 0 &amp; 1 &amp; 0 \\
\end{pmatrix}
\]</span> 思考题：n 平面和 f 平面的 z 值不变，但是中间的点的 z
值怎么变化呢？</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111218945.png"
alt="image-20230711下午121849936" />
<figcaption aria-hidden="true">image-20230711下午121849936</figcaption>
</figure>
<p>这个 frustum 只需要给定 <span class="math inline">\(fov_y\)</span>
和宽高比就能完全确定。</p>
<h2 id="canonial-cube-to-screen">Canonial cube to screen</h2>
<p>本质上是视口变换。</p>
<p>What is a screen?</p>
<ul>
<li>An array of pixels</li>
<li>Size of the array: resolution</li>
<li>A typical kind of raster display（屏幕是典型的光栅成像设备, raster
在德语中就是屏幕的意思, rasterize 就是把东西画在屏幕上）</li>
</ul>
<p>Define the screen space</p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111331976.png" alt="image-20230711下午13112350" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111335960.png" alt="image-20230711下午13510236" style="zoom:50%;" /></p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>



<script>
  MathJax = {
    tex: {
      inlineMath: [["$", "$"]],
    },
    displayMath: [
      ["$$", "$$"],
      ["\[\[", "\]\]"],
    ],
    svg: {
      fontCache: "global",
    },
  };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
></script>



 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  



 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












