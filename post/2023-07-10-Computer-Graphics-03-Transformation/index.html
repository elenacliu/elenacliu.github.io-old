<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="本文内容总结自闫令琪老师的《GAMES101-现代计算机图形学入门》。
课程主页：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html
网课链接：https://www.bilibili.com/video/BV1X7411F744
Transformation # Scale matrix # $$ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}= \begin{pmatrix}s_x & 0\\0 & s_y\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix} $$ Reflection matrix # $$ \begin{pmatrix}-x\\y\end{pmatrix}= \begin{pmatrix}-1 & 0\\0 & 1\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix} $$ Shear matrix # $$ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}=\begin{pmatrix}1&a\\0&1\end{pmatrix} \begin{pmatrix}x\\y\end{pmatrix} $$ Rotation matrix # 默认绕着原点、逆时针方向旋转。
Homogenous coordinates # 为什么要引入齐次坐标？因为平移变换不是一种线性变换。
平移变换无法直接表示成矩阵乘的形式。
$$ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}=\begin{pmatrix}a&b\\c&d\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}&#43;\begin{pmatrix}t_x\\t_y\end{pmatrix} $$ 解决方案：增加一个维度（w-coordinate） 2d point: $(x,y,1)^T$
2d vector：$(x,y,0)^T$
$\begin{pmatrix}x\\y\\w\end{pmatrix}$ Is the 2D point $\begin{pmatrix}x/w\\y/w\\1\end{pmatrix}$, $w\neq0$
一个点加上另一个点，在齐次坐标下表示的是两个点的中点。
Affine transformation # Affine map = linear map &#43; translation">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="Computer Graphics 03 Transformation" />
<meta property="og:description" content="本文内容总结自闫令琪老师的《GAMES101-现代计算机图形学入门》。
课程主页：https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html
网课链接：https://www.bilibili.com/video/BV1X7411F744
Transformation # Scale matrix # $$ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}= \begin{pmatrix}s_x & 0\\0 & s_y\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix} $$ Reflection matrix # $$ \begin{pmatrix}-x\\y\end{pmatrix}= \begin{pmatrix}-1 & 0\\0 & 1\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix} $$ Shear matrix # $$ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}=\begin{pmatrix}1&a\\0&1\end{pmatrix} \begin{pmatrix}x\\y\end{pmatrix} $$ Rotation matrix # 默认绕着原点、逆时针方向旋转。
Homogenous coordinates # 为什么要引入齐次坐标？因为平移变换不是一种线性变换。
平移变换无法直接表示成矩阵乘的形式。
$$ \begin{pmatrix}x&#39;\\y&#39;\end{pmatrix}=\begin{pmatrix}a&b\\c&d\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}&#43;\begin{pmatrix}t_x\\t_y\end{pmatrix} $$ 解决方案：增加一个维度（w-coordinate） 2d point: $(x,y,1)^T$
2d vector：$(x,y,0)^T$
$\begin{pmatrix}x\\y\\w\end{pmatrix}$ Is the 2D point $\begin{pmatrix}x/w\\y/w\\1\end{pmatrix}$, $w\neq0$
一个点加上另一个点，在齐次坐标下表示的是两个点的中点。
Affine transformation # Affine map = linear map &#43; translation" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://elenacliu.github.io/post/2023-07-10-Computer-Graphics-03-Transformation/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-07-10T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-07-10T00:00:00+00:00" />
<title>Computer Graphics 03 Transformation | cliu&#39;s Blog</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css" integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz&#43;OQteg=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.974376d2d80c3269dca4d041b07db9a52952667c7c241b68a8cc9fa5b26dc28a.js" integrity="sha256-l0N20tgMMmncpNBBsH25pSlSZnx8JBtoqMyfpbJtwoo=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>cliu&#39;s Blog</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  
















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Computer Graphics 03 Transformation</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#transformation">Transformation</a>
      <ul>
        <li><a href="#scale-matrix">Scale matrix</a></li>
        <li><a href="#reflection-matrix">Reflection matrix</a></li>
        <li><a href="#shear-matrix">Shear matrix</a></li>
        <li><a href="#rotation-matrix">Rotation matrix</a></li>
        <li><a href="#homogenous-coordinates">Homogenous coordinates</a></li>
        <li><a href="#affine-transformation">Affine transformation</a></li>
        <li><a href="#inverse-transformation">Inverse transformation</a></li>
        <li><a href="#composing-complex-transforms">Composing complex transforms</a></li>
        <li><a href="#decomposing-complex-transforms">Decomposing complex transforms</a></li>
        <li><a href="#3d-transforms">3D transforms</a>
          <ul>
            <li><a href="#rotation-around-x--y--or-z--axis">Rotation around x-, y-, or z- axis</a></li>
            <li><a href="#rodrigues-rotation-formula">Rodrigue&rsquo;s rotation formula</a></li>
          </ul>
        </li>
        <li><a href="#viewing-transformation">Viewing transformation</a>
          <ul>
            <li><a href="#view视图-camera-transformation">View（视图）/ camera transformation</a></li>
          </ul>
        </li>
        <li><a href="#projection-transformation">Projection Transformation</a>
          <ul>
            <li><a href="#orthographic-transformation">Orthographic transformation</a></li>
            <li><a href="#perceptive-transformation">Perceptive transformation</a></li>
          </ul>
        </li>
        <li><a href="#canonial-cube-ndc-to-screen">Canonial cube (NDC) to screen</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><p>本文内容总结自闫令琪老师的《GAMES101-现代计算机图形学入门》。</p>
<p>课程主页：<a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html</a></p>
<p>网课链接：<a href="https://www.bilibili.com/video/BV1X7411F744/">https://www.bilibili.com/video/BV1X7411F744</a></p>
<h1 id="transformation">
  Transformation
  <a class="anchor" href="#transformation">#</a>
</h1>
<h2 id="scale-matrix">
  Scale matrix
  <a class="anchor" href="#scale-matrix">#</a>
</h2>
<div>$$
\begin{pmatrix}x'\\y'\end{pmatrix}=
\begin{pmatrix}s_x & 0\\0 & s_y\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}
$$</div>
<h2 id="reflection-matrix">
  Reflection matrix
  <a class="anchor" href="#reflection-matrix">#</a>
</h2>
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102153297.png" alt="image-20230710下午44412437" style="zoom:50%;" />
<div>$$
\begin{pmatrix}-x\\y\end{pmatrix}=
\begin{pmatrix}-1 & 0\\0 & 1\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}
$$</div>
<h2 id="shear-matrix">
  Shear matrix
  <a class="anchor" href="#shear-matrix">#</a>
</h2>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102153520.png" alt="image-20230710下午44643013" /></p>
<div>$$
\begin{pmatrix}x'\\y'\end{pmatrix}=\begin{pmatrix}1&a\\0&1\end{pmatrix}
\begin{pmatrix}x\\y\end{pmatrix}
$$</div>
<h2 id="rotation-matrix">
  Rotation matrix
  <a class="anchor" href="#rotation-matrix">#</a>
</h2>
<p>默认绕着原点、逆时针方向旋转。</p>
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102153951.png" alt="image-20230710下午45946837" style="zoom:50%;" />
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102153578.png" alt="image-20230710下午50130812" style="zoom:50%;" />
<h2 id="homogenous-coordinates">
  Homogenous coordinates
  <a class="anchor" href="#homogenous-coordinates">#</a>
</h2>
<p>为什么要引入齐次坐标？因为平移变换不是一种线性变换。</p>
<p>平移变换无法直接表示成矩阵乘的形式。</p>
<div>$$
\begin{pmatrix}x'\\y'\end{pmatrix}=\begin{pmatrix}a&b\\c&d\end{pmatrix}\begin{pmatrix}x\\y\end{pmatrix}+\begin{pmatrix}t_x\\t_y\end{pmatrix}
$$</div>
解决方案：增加一个维度（w-coordinate）
<p>2d point: $(x,y,1)^T$</p>
<p>2d vector：$(x,y,0)^T$</p>
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102153412.png" alt="image-20230710下午53642136" style="zoom:50%;" />
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102154016.png" alt="image-20230710下午54417840" style="zoom:50%;" />
<p><code>$\begin{pmatrix}x\\y\\w\end{pmatrix}$</code> Is the 2D point <code>$\begin{pmatrix}x/w\\y/w\\1\end{pmatrix}$</code>, <code>$w\neq0$</code></p>
<p>一个点加上另一个点，在齐次坐标下表示的是两个点的中点。</p>
<h2 id="affine-transformation">
  Affine transformation
  <a class="anchor" href="#affine-transformation">#</a>
</h2>
<p>Affine map = linear map + translation</p>
<div>$$
\begin{pmatrix}x'\\y'\end{pmatrix}=
\begin{pmatrix}a & b\\c & d\end{pmatrix}\cdot
\begin{pmatrix}x \\ y\end{pmatrix} + 
\begin{pmatrix}t_x\\t_y\end{pmatrix}
$$</div>
using homogenous coordinates:
<div>$$
\begin{pmatrix}x'\\y'\\1\end{pmatrix}=
\begin{pmatrix}a & b & t_x \\ c & d & t_y \\ 0 & 0 & 1\end{pmatrix}\cdot
\begin{pmatrix}x\\y\\1\end{pmatrix}
$$</div>
<p>表示 2D 场景下的仿射变换时，最后一行才是 0 0 1（比如投影变换就不是）。</p>
<p>类似的，四元组可以方便地表示 3D 空间的线性变换。</p>
<p>关于四元组的学习资料：</p>
<ol>
<li><a href="https://krasjet.github.io/quaternion/quaternion.pdf">https://krasjet.github.io/quaternion/quaternion.pdf</a></li>
<li>如何形象地理解四元数？ - 知乎 <a href="https://www.zhihu.com/question/23005815/answer/483589712">https://www.zhihu.com/question/23005815/answer/483589712</a></li>
</ol>
<h2 id="inverse-transformation">
  Inverse transformation
  <a class="anchor" href="#inverse-transformation">#</a>
</h2>
<p>$\mathrm{M}^{-1}$ is the inverse of transform $\mathrm{M}$</p>
<h2 id="composing-complex-transforms">
  Composing complex transforms
  <a class="anchor" href="#composing-complex-transforms">#</a>
</h2>
<p>复杂的变换可以通过一系列简单的变换得到，但是变换的过程非常重要。</p>
<div>$$
A_n(...A_2(A_1(\mathrm{x})))=\mathrm{A}_n\cdots \mathrm{A}_2\cdot\mathrm{A}_1\cdot\begin{pmatrix}x\\y\\1\end{pmatrix}
$$</div>
<h2 id="decomposing-complex-transforms">
  Decomposing complex transforms
  <a class="anchor" href="#decomposing-complex-transforms">#</a>
</h2>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102154150.png" alt="image-20230710下午82416312" /></p>
<div>$$
R_\theta=\begin{pmatrix}\cos\theta&-\sin\theta\\\sin\theta&\cos\theta\end{pmatrix}
$$</div>
<div>$$
R_{-\theta}=R_\theta^T
$$</div>
<div>$$
R_{-\theta}=R_{\theta}^{-1}, by\ definition
$$</div>
<p>（因为逆时针旋转$\theta$和顺时针旋转$\theta$就是互逆的操作）</p>
<p>注意：逆矩阵和转置矩阵相等的矩阵叫做正交矩阵。</p>
<h2 id="3d-transforms">
  3D transforms
  <a class="anchor" href="#3d-transforms">#</a>
</h2>
<p>Using homogenous coordinates again:</p>
<ul>
<li>3D point = $(x,y,z,1)^T$</li>
<li>3D vector = $(x,y,z,0)^T$</li>
</ul>
<p>In general, $(x,y,z,w), w\neq0$ is the 3D point:</p>
<div>$$
(x/w,y/w,z/w)
$$</div>
<p>Use 4x4 matrices for affine transformations:</p>
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102154039.png" alt="image-20230710下午90105276" style="zoom:50%;" />
<p>Linear transformation first, then translation.</p>
<h3 id="rotation-around-x--y--or-z--axis">
  Rotation around x-, y-, or z- axis
  <a class="anchor" href="#rotation-around-x--y--or-z--axis">#</a>
</h3>
<p>绕着 x- axis 旋转：</p>
<div>$$
\mathrm{R}_x(\alpha)=
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & \cos\alpha &-\sin\alpha & 0\\
0 & \sin\alpha & \cos\alpha & 0\\
0 & 0 & 0 & 1
\end{pmatrix}
$$</div>
<p>绕着 y- axis 旋转：</p>
<div>$$
\mathrm{R}_y(\alpha)=
\begin{pmatrix}
\cos\alpha & 0 & \sin\alpha & 0 \\
0 & 1 & 0 & 0\\
-\sin\alpha & 0 & \cos\alpha & 0\\
0 & 0 & 0 & 1
\end{pmatrix}
$$</div>
<p>注意这里绕着 y- axis 旋转之所以左上角是 $\sin\alpha$ 而非 $-\sin\alpha$，是因为课程默认右手系，从 y 轴的角度看，应该是 z 轴充当 2D 平面上的 x 轴，x 轴充当 2D 平面上的 y 轴（这样才能符合右手螺旋定则得到 y 轴的方向，并且依照右手旋转的方向定出 $z-O-x$ 平面的逆时针方向就是手转动的方向：从 z 轴指向 x 轴），而在这里矩阵中的顺序是先 x 轴后 z 轴，是反的，所以 $x-O-z$ 平面的顺时针方向等于 $z-O-x$ 平面的逆时针方向，角度需要添加负号。</p>
<p>（本质上是因为轮换顺序反了，即便是左手系也会出现这个问题）</p>
<p>绕着 z- axis 旋转：</p>
<div>$$
\mathrm{R}_z(\alpha)=
\begin{pmatrix}
\cos\alpha & -\sin\alpha & 0 & 0 \\
\sin\alpha & \cos\alpha & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 &0 & 1
\end{pmatrix}
$$</div>
<p>欧拉角：</p>
<div>$$
\mathrm{R}_{xyz}(\alpha,\beta,\gamma)=\mathrm{R}_x(\alpha)\mathrm{R}_y(\beta)\mathrm{R}_z(\gamma)
$$</div>
<h3 id="rodrigues-rotation-formula">
  Rodrigue&rsquo;s rotation formula
  <a class="anchor" href="#rodrigues-rotation-formula">#</a>
</h3>
<p>rotation by angle $\alpha$ around axis $\mathrm{n}$:</p>
<p>只有向量表示旋转轴不太合理，因此这里默认是过原点的向量。</p>
<div>$$
\mathrm{R}(\mathrm{n},\alpha)=\cos(\alpha)\mathrm{I}+(1-\cos(\alpha))\mathrm{n}\mathrm{n}^T+\sin(\alpha)
\begin{pmatrix}
0 & -n_z & n_y \\
n_z & 0 & -n_x \\
-n_y & n_x & 0 \\
\end{pmatrix}
$$</div>
最后的矩阵就是叉积的 dual matrix。
<p>四元数：为了旋转与旋转之间的插值。</p>
<p>比如：二维旋转15度对应矩阵$A$，二维旋转25度对应矩阵$B$，$(A+B)/2$代表的矩阵并不是旋转20度的矩阵。</p>
<h2 id="viewing-transformation">
  Viewing transformation
  <a class="anchor" href="#viewing-transformation">#</a>
</h2>
<h3 id="view视图-camera-transformation">
  View（视图）/ camera transformation
  <a class="anchor" href="#view%e8%a7%86%e5%9b%be-camera-transformation">#</a>
</h3>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102154026.png" alt="image-20230710下午93933212" /></p>
<p>相机在世界坐标系中的位置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102154183.png" alt="image-20230710下午94454590" /></p>
<p>相机坐标系：</p>
<p>约定相机位于原点，向上方向为 y 方向，朝着 -z 方向看。</p>
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307102154852.png" alt="image-20230710下午94325730" style="zoom:50%;" />
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111029900.png" alt="image-20230711上午102918552" /></p>
<p>将相机从世界坐标系“移动”到相机坐标系（本质上是坐标系的变换，但是老师认为坐标系的改变导致物体坐标变化不好理解，拿物体的移动举例更容易理解）</p>
<ul>
<li>
<p>translates e to origin</p>
<div>$$
T_{view}=
\begin{bmatrix}
1 & 0 & 0 & -x_e \\
0 & 1 & 0 & -y_e \\
0 & 0 & 1 & -z_e \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$</div>
</li>
<li>
<p>rotates g to -Z, rotates t to Y, rotates (g x t) to X</p>
<ul>
<li>consider its <em>inverse</em> rotation: X to (g x t), Y to t, Z to -g
<div>$$
R^{-1}_{view}=
\begin{bmatrix}
x_{\hat g\times\hat t} & x_t & x_{-g} & 0 \\
y_{\hat g\times\hat t} & y_t & y_{-g} & 0 \\
z_{\hat g\times\hat t} & z_t & z_{-g} & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$</div>
由于旋转矩阵是正交矩阵，所以它的逆矩阵等于它的转置：
<div>$$
R_{view}=
\begin{bmatrix}
x_{\hat g\times\hat t} & y_{\hat g\times\hat t} & z_{\hat g\times\hat t} & 0 \\
x_t & y_t & z_t & 0 \\
x_{-g} & y_{-g} & z_{-g} & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$</div>
</li>
</ul>
</li>
</ul>
<p>因此，视图变换的矩阵是：</p>
<div>$$
M_{view}=R_{view}T_{view}
$$</div>
<h2 id="projection-transformation">
  Projection Transformation
  <a class="anchor" href="#projection-transformation">#</a>
</h2>
<p>3D to 2D</p>
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111045525.png" alt="image-20230711上午104444349" /></p>
<h3 id="orthographic-transformation">
  Orthographic transformation
  <a class="anchor" href="#orthographic-transformation">#</a>
</h3>
<p>正交投影，3D 的平行线在 2D 上还是平行的。</p>
<p>这里的 a cuboid [l, r] x [b ,t] x [f, n] 就是 clip space.</p>
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111048018.png" alt="image-20230711上午104812676" style="zoom:50%;" />
<p>b: bottom</p>
<p>t: top</p>
<p>f: far, z 小</p>
<p>n: near, z 大</p>
<p>这也就是为什么 OpenGL 选择的是左手系，因为这样 far 就比 near 的 z 值更大了。</p>
<p>Translate (center to origin) first, then scale to length/width/height to 2</p>
<div>$$
M_{ortho}=
\begin{pmatrix}
\frac{2}{r-t} & 0 & 0 & 0 \\
0 & \frac{2}{t-b} & 0 & 0 \\
0 & 0 & \frac{2}{n-f} & 0 \\
0 & 0 & 0 & 1 \\
\end{pmatrix}
\begin{pmatrix}
1 & 0 & 0 & -\frac{r+t}{2} \\
0 & 1 & 0 & -\frac{t+b}{2} \\
0 & 0 & 1 & -\frac{n+f}{2} \\
0 & 0 & 0 & 1 \\
\end{pmatrix}
$$</div>
投影变换的过程会出现 cube 中物体的拉伸，但是最后会进行视口的变换，会 scale 回来。
<h3 id="perceptive-transformation">
  Perceptive transformation
  <a class="anchor" href="#perceptive-transformation">#</a>
</h3>
<p>透视投影，近大远小。</p>
<p>相机有个 frustum</p>
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111115615.png" alt="image-20230711上午110351824" style="zoom:50%;" />
<p>先将远的大平面“挤”成和近的平面一样大的平面，再做正交投影。</p>
<div>$$
M_{persp2ortho}=
$$</div>
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111115310.png" alt="image-20230711上午111239716" style="zoom:50%;" />
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111115034.png" alt="image-20230711上午111344189" style="zoom:50%;" />
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111115001.png" alt="image-20230711上午111530145" style="zoom:50%;" />
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111116351.png" alt="image-20230711上午111628919" style="zoom:50%;" />
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111132377.png" alt="image-20230711上午113237717" style="zoom:50%;" />
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111200562.png" alt="image-20230711下午120053458" style="zoom:50%;" />
<div>$$
M_{persp2ortho}=
\begin{pmatrix}
n & 0 & 0 & 0 \\
0 & n & 0 & 0 \\
0 & 0 & n + f & -nf \\
0 & 0 & 1 & 0 \\
\end{pmatrix}
$$</div>
思考题：n 平面和 f 平面的 z 值不变，但是中间的点的 z 值怎么变化呢？答案：会更靠近较远的 f 平面。
<p><img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111218945.png" alt="image-20230711下午121849936" /></p>
<p>这个 frustum 只需要给定 $fov_y$ 和宽高比就能完全确定。</p>
<h2 id="canonial-cube-ndc-to-screen">
  Canonial cube (NDC) to screen
  <a class="anchor" href="#canonial-cube-ndc-to-screen">#</a>
</h2>
<p>本质上是视口变换。</p>
<p>What is a screen?</p>
<ul>
<li>An array of pixels</li>
<li>Size of the array: resolution</li>
<li>A typical kind of raster display（屏幕是典型的光栅成像设备, raster 在德语中就是屏幕的意思, rasterize 就是把东西画在屏幕上）</li>
</ul>
<p>Define the screen space</p>
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111331976.png" alt="image-20230711下午13112350" style="zoom:50%;" />
<img src="https://cdn.jsdelivr.net/gh/elenacliu/PicGoPics/img/202307111335960.png" alt="image-20230711下午13510236" style="zoom:50%;" /></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>



<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<style>
code.has-jax {
  -webkit-font-smoothing: antialiased;
  background: inherit !important;
  border: none !important;
  font-size: 100%;
}
</style>



 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#transformation">Transformation</a>
      <ul>
        <li><a href="#scale-matrix">Scale matrix</a></li>
        <li><a href="#reflection-matrix">Reflection matrix</a></li>
        <li><a href="#shear-matrix">Shear matrix</a></li>
        <li><a href="#rotation-matrix">Rotation matrix</a></li>
        <li><a href="#homogenous-coordinates">Homogenous coordinates</a></li>
        <li><a href="#affine-transformation">Affine transformation</a></li>
        <li><a href="#inverse-transformation">Inverse transformation</a></li>
        <li><a href="#composing-complex-transforms">Composing complex transforms</a></li>
        <li><a href="#decomposing-complex-transforms">Decomposing complex transforms</a></li>
        <li><a href="#3d-transforms">3D transforms</a>
          <ul>
            <li><a href="#rotation-around-x--y--or-z--axis">Rotation around x-, y-, or z- axis</a></li>
            <li><a href="#rodrigues-rotation-formula">Rodrigue&rsquo;s rotation formula</a></li>
          </ul>
        </li>
        <li><a href="#viewing-transformation">Viewing transformation</a>
          <ul>
            <li><a href="#view视图-camera-transformation">View（视图）/ camera transformation</a></li>
          </ul>
        </li>
        <li><a href="#projection-transformation">Projection Transformation</a>
          <ul>
            <li><a href="#orthographic-transformation">Orthographic transformation</a></li>
            <li><a href="#perceptive-transformation">Perceptive transformation</a></li>
          </ul>
        </li>
        <li><a href="#canonial-cube-ndc-to-screen">Canonial cube (NDC) to screen</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












